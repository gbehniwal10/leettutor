{
  "id": "regular-expression-matching",
  "title": "Regular Expression Matching",
  "difficulty": "hard",
  "tags": [
    "recursion",
    "string",
    "dynamic-programming"
  ],
  "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n \nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n \nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
  "starter_code": "def isMatch(s: str, p: str) -> bool:\n    # Your code here\n    pass\n",
  "function_name": "isMatch",
  "test_cases": [
    {
      "input": {
        "s": "aa",
        "p": "a*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aab",
        "p": "c*a*b"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "ab",
        "p": ".*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    }
  ],
  "hidden_test_cases": [
    {
      "input": {
        "s": "aa",
        "p": "a"
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "mississippi",
        "p": "mis*is*p*."
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aabbccddeeff",
        "p": "a*b*c*d*e*f*f*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abababa",
        "p": "(ab)*a"
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abcde",
        "p": "a*.*e"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "ababcd",
        "p": "a.*a.*d"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aabbbbc",
        "p": "a*b*c"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aaaaaa",
        "p": "a*a*a*a*a*a"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aabb",
        "p": "ab*a*b*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abcccccaaaa",
        "p": "ab*c*a*.*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abcdef",
        "p": "abc.*f"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "ababab",
        "p": "(ab)*"
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "ab",
        "p": "a*b*c*d*.*e*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "xaymz",
        "p": "x.*z"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "xaybz",
        "p": "xa*y*b*z"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abcdefgh",
        "p": "a*d*fh"
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "aaa",
        "p": "a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "mississippi",
        "p": "mi*ss*is*si*p*i*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "zzzz",
        "p": "z*"
      },
      "expected": true,
      "function_call": "isMatch(**test_input)"
    },
    {
      "input": {
        "s": "abcdefgh",
        "p": "a.h"
      },
      "expected": false,
      "function_call": "isMatch(**test_input)"
    }
  ],
  "hints": [],
  "optimal_complexity": {
    "time": "",
    "space": ""
  }
}