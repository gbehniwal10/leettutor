{
  "id": "two-sum",
  "title": "Two Sum",
  "difficulty": "easy",
  "tags": [
    "array",
    "hash-map"
  ],
  "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers that add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n```\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n```\n**Example 2:**\n\n```\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n```\n**Constraints:**\n- 2 <= nums.length <= 10^4\n- -10^9 <= nums[i] <= 10^9\n- -10^9 <= target <= 10^9\n- Only one valid answer exists.\n",
  "starter_code": "def twoSum(nums: list[int], target: int) -> list[int]:\n    # Your code here\n    pass\n",
  "function_name": "twoSum",
  "test_cases": [
    {
      "input": {
        "nums": [
          2,
          7,
          11,
          15
        ],
        "target": 9
      },
      "expected": [
        0,
        1
      ],
      "function_call": "twoSum(**test_input)"
    },
    {
      "input": {
        "nums": [
          3,
          2,
          4
        ],
        "target": 6
      },
      "expected": [
        1,
        2
      ],
      "function_call": "twoSum(**test_input)"
    },
    {
      "input": {
        "nums": [
          3,
          3
        ],
        "target": 6
      },
      "expected": [
        0,
        1
      ],
      "function_call": "twoSum(**test_input)"
    }
  ],
  "hidden_test_cases": [
    {
      "input": {
        "nums": [
          1,
          2,
          3,
          4,
          5
        ],
        "target": 9
      },
      "expected": [
        3,
        4
      ],
      "function_call": "twoSum(**test_input)"
    }
  ],
  "hints": [
    "What data structure allows O(1) lookup?",
    "For each number, what are you looking for?",
    "Can you store numbers you've seen as you iterate?"
  ],
  "optimal_complexity": {
    "time": "O(n)",
    "space": "O(n)"
  }
}
